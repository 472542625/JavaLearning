volatile

java内存分为主内存、本地内存（某个线程内的）



假设有变量count=0，存在主内存当中
假如有两个线程t1、t2都执行count = count + 1



如果发生了了线程不同步的话，（异常）
t1执行count = count + 1 //此时count = 1 了
这时候t2里面的count也等于0，,执行count = count + 1的话，此时count也 = 1



线程同步的话，（正常----线程可见性）
t1执行count = count + 1 //此时count = 1 了
然后count = 1 刷新 到主内存当中
这时候t2里面的count等于1了，,执行count = count + 1的话，此时count = 2














volatile
1帮助理解
・・・・Volatile的第一个语义就是保证此线程的可见性，给某个线程内的变量加了这个关键字的话，就是当某个线程执行改值后立刻强制刷新到主内存当中，因此一个线程对此变量的更改其他线程是立即可知的。
・・・・对于volatile修饰的变量，jvm虚拟机只是保证从主内存加载到线程工作内存的值是最新的

2帮助理解 
（重点，为什么volatile会有线程不安全性）
即便线程立即可以知道主内存中最新的值，但是
线程工作流程有 read-load-use-asign（赋值修改）-store-write之后才会更新同步到主内存中，如果在read-load（加载主内存中最新的值A）之后，主内存的最新的值又被修改成了B，

但是线程中已经加载了值，用的还是值A，接着执行下一步use等等，因此还是会发生 线程不安全性








